{
    "contents" : "library(MASS) # for multivariate Gaussian simulation\nlibrary(RSQMC) # for internal filters\nlibrary(profvis) # R profiler\nlibrary(parallel)\nsource(\"/Users/Schreuder/Google Drive/ENSAE/2A/Stage2A/bRistol/Example1Functions.R\") \n\nset.seed(41)\n\n## Parameters ##\nT_ <- 20 # time\nD <- 8 # dimension of x\nsigma_y <- .25**2 # variance of y|x\nM <- 16 # number of internal particles\nN <- 100 # number of external particles\ntau <- 1. # coordinates variance\nlambda <- 1. # coordinates correlation\nnb_filters <- 1 # number of external filters \n\n## Covariance matrix \nS = covariance_matrix(D, tau, lambda)\n\n# State-space model\nSSM = state_space_model(D, T_, S, sigma_y)\nx = SSM$X\ny = SSM$Y\n\ndf = data.frame(x = x[2, ], y= y[2,])\ndf$idu <- as.numeric(row.names(df))\nggplot(df) + geom_point(aes(x=idu, y=y, color='Observation'), size=2)+ geom_line(aes(x=idu, y=x, color='Latent variable'), size=1) + xlab('Time') + ylab('Value')\n\n\n\n## Without QMC ## \n\n#profvis({\npred_without_QMC <- array(0, dim=c(nb_filters, D, T_))\n\nparticles <- array(0, dim=c(N, D, T_+1))\nweights <- matrix(0, N)\nlog_likelihood <- matrix(0, N)\ninternal_weights <- array(0, dim=c(T_+1, M, D, N))\ninternal_particles <- array(0, dim=c(T_+1, M, D, N))\n\nfor(f in 1:nb_filters){\n  print(c(\"Filter without QMC nÂ°\", f))\n\n  # External particles initialization\n  particles[, , 1] <- mvrnorm(n = N, matrix(0, D), S)\n  \n  for(t in 2:(T_+1)){\n    print(t)\n    # Internal filter \n    # Returns the log-likelihood ( = weights for resampling)\n    internal_filter_output = internal_filter(N, y[, t-1], M, D, S, particles[, , t-1], sigma_y)\n    internal_weights[t, , , ] <- internal_filter_output$Weights\n    internal_particles[t, , ,] <- internal_filter_output$Particles\n    log_likelihood <- internal_filter_output$Log_Likelihood\n  \n    # Weights normalization\n    weights = exp(log_likelihood - max(log_likelihood))\n    sum = sum(weights)\n    weights = weights/sum\n\n    resampling = sample(N, replace = T, prob = weights)\n    \n    # Backward\n    cl <- makeCluster(3)\n    particles[, , t] <- t(parSapply(cl, 1:N, backward_paralell, resampling=resampling, N=N, M=M, t=t, D=D, weights=weights, particles=particles, internal_particles=internal_particles, internal_weights=internal_weights, S=S))\n    stopCluster(cl)\n  }\n  pred_without_QMC[f, , ] <- apply(particles[ , ,2:(T_+1)], c(2,3), mean)\n}\n#})\n\n### QMC ###\n\npred_with_QMC <- array(0, dim=c(nb_filters, D, T_))\n\nparticles <- array(0, dim=c(N, D, T_+1))\nweights <- matrix(0, N)\nlog_likelihood <- matrix(0, N)\ninternal_weights <- array(0, dim=c(T_+1, M, D, N))\ninternal_particles <- array(0, dim=c(T_+1, M, D, N))\n\nfor(f in 1:nb_filters){\n  print(c(\"Filter with QMC\", f))\n  \n  # Initialize particles : particles * components * time\n  particles[, , 1] <- mvrnorm(n = N, matrix(0, D), S)\n  \n  for(t in 2:(T_+1)){\n    print(t)\n    internal_filter_output = internal_filter_with_QMC(N, y[, t-1], M, D, S, particles[, , t-1], sigma_y)\n    internal_weights[t, , , ] <- internal_filter_output$Weights\n    internal_particles[t, , ,] <- internal_filter_output$Particles\n    log_likelihood <- internal_filter_output$Log_Likelihood\n    \n    # Weights normalization\n    weights = exp(log_likelihood - max(log_likelihood))\n    sum = sum(weights)\n    weights = weights/sum\n    \n    # Resampling\n    resampling = sample(N, replace = T, prob = weights)\n    \n    cl <- makeCluster(3)\n    particles[, , t] <- t(parSapply(cl, 1:N, backward_paralell, resampling=resampling, N=N, M=M, t=t, D=D, weights=weights, particles=particles, internal_particles=internal_particles, internal_weights=internal_weights, S=S))\n    stopCluster(cl)\n  }\n  pred_with_QMC[f, , ] <- apply(particles[ , ,2:(T_+1)], c(2,3), mean)\n}\n\n\nlibrary(ggplot2)\nplot_coordinate = 2\ndf = data.frame(real_value = x[plot_coordinate, ], no_QMC=pred_without_QMC[1, plot_coordinate, ], QMC=pred_with_QMC[1, plot_coordinate, ])\ndf$idu <- as.numeric(row.names(df))\nggplot(df) + geom_point(aes(x=idu, y=real_value, color='Real value'))+ geom_line(aes(x=idu, y=no_QMC, color='Without QMC')) + geom_line(aes(x=idu, y=QMC, color='With QMC')) \n\nvar = apply(pred_without_QMC[ , , ], c(2,3), var)\nmean_var= apply(var , 2, mean)\n\nvar_QMC = apply(pred_with_QMC[ , ,], c(2,3), var)\nmean_var_QMC = apply(var_QMC , 2, mean)\n\nvar_ratio = data.frame(variance_ratio = apply(var_QMC/mean_var_QMC, 2, mean))\n\nggplot(var_ratio) + geom_line(aes(x=1:T_, y=variance_ratio), colour='blue') + geom_hline(yintercept = 1)\n\nvars = data.frame(var = apply(var, 2, mean), var_QMC = apply(var_QMC, 2, mean))\nggplot(vars) + geom_line(aes(x=1:T_, y=var, colour='blue'), size=1.5) + geom_line(aes(x=1:T_, y=var_QMC, colour='green'), size=1.5) + scale_color_discrete(name = \"Variances\", labels = c(\"Without QMC\", \"With QMC\"))\n\n\nif (1==1){\n## Naive SMC ##\nlibrary(mvtnorm)\n\npred_naive <- array(0, dim=c(D, T_))\n\n# External particles initialization\nparticles <- array(0, dim=c(N, D, T_+1))\nparticles[, , 1] <- mvrnorm(n = N, matrix(0, D), S)\n\nW <- matrix(0, N, T_)\n\nfor(n in 1:N){\n  W[n, 1] = dmvnorm(x=y[, 1], mean=particles[n, ,1], sigma=diag(sigma_y, D)) * dmvnorm(x=particles[n, ,1], mean=matrix(0, D), sigma=S)\n}\n\nW[, 1] = W[,1]/sum(W[, 1])\n\nfor(t in 2:(T_)){\n  # Resampling\n  resampling <- sample(N, replace = T, prob = W[, t-1])\n  \n  for(n in 1:N){\n    particles[n, ,t] = mvrnorm(n = 1, particles[resampling[n] , ,t-1], S)\n  }\n  \n  for(n in 1:N){\n    W[n, t] = dmvnorm(x=y[, t], mean=particles[n, , t], sigma=diag(sigma_y, D))\n  }\n  \n  W[, t] = W[,t]/sum(W[, t])\n  \n}\n\n# Backward smoothing/sampling\nbackward_particles = array(0, dim=c(N, D, T_))\n\nresampling = sample(N, replace = T_, prob = W[,T_])\n\nbackward_particles[,,T_] = particles[resampling, ,T_]\n\nwgts = array(0, N)\n\n# Backward pass\nfor(t in (T_-1):1){\n  for(n in 1:N){\n  wgts[n] = W[n,t]*dmvnorm(backward_particles[n, ,t+1], particles[n, , t], S)\n  }\n  resampling = sample(N, replace = T, prob = wgts)\n  backward_particles[,,t] = particles[resampling, , t]\n}\n\npred_naive[2, 2:T_] <- apply(backward_particles[, 2,2:(T_)], 2, mean)\n\nplot_coordinate = 2\n\nnaive = data.frame(real_value = x[plot_coordinate, ], pred = pred_naive[plot_coordinate, ])\nggplot(naive) + geom_line(aes(x=1:T_, y=real_value, colour='Real value'), size=1) + geom_line(aes(x=1:T_, y=pred, colour='Prediction'), size=1) + xlab('Time') + ylab('Value') + annotate(\"text\", x = 18, y = 1, label = \"n_x = 2\")\n}",
    "created" : 1501672296971.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3972870992",
    "id" : "44EB843B",
    "lastKnownWriteTime" : 1501696263,
    "path" : "~/Google Drive/ENSAE/2A/Stage2A/bRistol/Example1.R",
    "project_path" : "Example1.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}
{
    "contents" : "// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(BH)]]\n#include <RcppArmadillo.h>\n#include <random>\n#include <iostream>\n#include <R.h>\n#include <math.h>\n#include <vector>\n\n#include <boost/random/mersenne_twister.hpp>\n#include <boost/math/distributions/normal.hpp>\n#include <boost/math/distributions/poisson.hpp>\nusing boost::math::normal;\n\n#include <boost/random.hpp>\n#include <boost/random/normal_distribution.hpp>\n\n\n\n#include \"../inst/include/SamplePack/DigitalNetsBase2.h\"\n#include \"../inst/include/Generate_RQMC.hpp\"\n\n\nusing namespace Rcpp;\n\n// http://thecoatlessprofessor.com/programming/set_rs_seed_in_rcpp_sequential_case/\n// [[Rcpp::export]]\nvoid set_seed(unsigned int seed) {\n    Rcpp::Environment base_env(\"package:base\");\n    Rcpp::Function set_seed_r = base_env[\"set.seed\"];\n    set_seed_r(seed);\n}\n\n// [[Rcpp::export]]\narma::vec StratifiedSampling(const double n){\n    // auto-cast in argument (from int to double)\n    // Stratified sampling over [0,1], returns n sorted uniforms\n    std::mt19937 generator(134);\n    arma::vec x = arma::zeros(n);\n    for(int i=0; i<n; i++){\n        double a = i/n;\n        double b = (i+1)/n;\n        std::uniform_real_distribution<double> unif(a,b);\n        x(i) = unif(generator);\n    }\n    return x;\n};\n\n// [[Rcpp::export]]\narma::vec Multinomial(int n, arma::vec weights){\n    arma::vec unif = StratifiedSampling(n);\n    double sum_weights = weights(0);\n    int k = 0;\n    arma::vec sample = arma::zeros(n);\n    \n    for(int i=0; i<n;i++){\n        while (unif[i] > sum_weights){\n            k++;\n            sum_weights += weights[k];\n        }\n        sample[i] = k;\n    }\n    return sample;\n}\n\n// [[Rcpp::export]]\narma::vec Sample(arma::mat particles_weights, const int nb_particles, const int time){\n    // Return multinomial sample\n    return Multinomial(nb_particles, particles_weights.col(time));\n}\n\n// [[Rcpp::export]]\ndouble G(const double &y, const double &x, const double &sigma){\n    // Density of Y | X=x\n    normal N(x,sigma);\n    return pdf(N,y);\n}\n\n// [[Rcpp::export]]\ndouble F(const double &x, const double &mu, const double &sigma){\n    // Kernel associated to the markov chain X_t\n    normal N(mu, sigma);\n    return pdf(N, x);\n}\n\n\n// [[Rcpp::export]]\narma::mat gen_sobol(const int D, const int M){\n  Scrambled* a;\n  a = Scrambled_Create(1, D, M);\n  arma::mat sobol_sequence(D, M, arma::fill::zeros);\n  Scrambled_Randomize(a);\n  vector<double> sobol_seq;\n  sobol_seq = Scrambled_GetPoints(a, D, M);\n  \n  for(int m=0; m<M; m++){\n    for(int d=0; d<D; d++){\n      sobol_sequence(d, m) = sobol_seq.at(d + D*m);\n    }\n  }\n  return sobol_sequence;\n}\n\narma::mat gen_sobol(const int D, const int M, Scrambled* a){\n  arma::mat sobol_sequence(D, M, arma::fill::zeros);\n  Scrambled_Randomize(a);\n  vector<double> sobol_seq;\n  sobol_seq = Scrambled_GetPoints(a, D, M);\n  \n  for(int m=0; m<M; m++){\n    for(int d=0; d<D; d++){\n      sobol_sequence(d, m) = sobol_seq.at(d + D*m);\n    }\n  }\n  return sobol_sequence;\n}\n\n// [[Rcpp::export]]\narma::vec SMC(arma::vec y, const int M, const int T){\n    \n    set_seed(42);\n    boost::mt19937 rng;\n    \n    arma::mat particles(M, T, arma::fill::zeros);\n    arma::mat weights(M, T, arma::fill::zeros);\n    \n    // Initial particles\n    for(int i=0; i<M; i++){\n        particles(i,0) = R::rnorm(0, 1);\n        weights(i,0) = G(y(0), particles(i,0), 1.)*F(particles(i,0),0.,1.);\n    }\n    \n    // Normalization\n    double sum_weights = sum(weights.col(0));\n    for(int i=0; i<M; i++){\n        weights(i,0) /= sum_weights;\n    }\n    \n    arma::vec x_pred(T);\n    \n    x_pred(0) = dot(weights.col(0), particles.col(0));\n    \n    for(int t=1; t<T; t++){\n        arma::vec resampling = Multinomial(M, weights.col(t-1));\n        \n        for(int m=0; m<M; m++){\n            // boost::normal_distribution<> nd(particles(resampling(m), t-1), 1.0);\n            // boost::variate_generator<boost::mt19937&, boost::normal_distribution<> > var_nor(rng, nd);\n            // particles(m, t) = var_nor();\n            particles(m, t) = R::rnorm(particles(resampling(m), t-1), 1.);\n            weights(m,t) = G(y(t), particles(m,t), 1.);\n        }\n        \n        sum_weights = sum(weights.col(t));\n        for(int m=0; m<M; m++){\n            weights(m,t) /= sum_weights;\n        }\n        \n        x_pred(t) = dot(weights.col(t), particles.col(t));\n    }\n    \n    \n    // Backward smoothing/sampling\n    arma::mat backward_particles(M, T, arma::fill::zeros);\n    arma::vec resampling = Multinomial(M, weights.col(T-1));\n    \n    for(int m=0; m<M; m++){\n        backward_particles(m, T-1) = particles(resampling(m), T-1);\n    }\n    \n    arma::vec wgts(M);\n    \n    for(int t=(T-2); t>=0; t--){\n        double sum = 0;\n        for(int m=0; m<M; m++){\n            wgts(m) = weights(m,t)*F(backward_particles(m,t+1), particles(m,t), 1.);\n            sum += wgts(m);\n        }\n        \n        for(int m=0; m<M; m++){\n            wgts(m) /= sum;\n        }\n        \n        resampling = Multinomial(M, wgts);\n        \n        for(int m=0; m<M; m++){\n            backward_particles(m, t) = particles(resampling(m), t);\n        }\n    }\n    arma::vec x_smooth(T);\n    for(int t=0; t<T; t++){\n        x_smooth[t] = mean(backward_particles.col(t));\n    }\n    return x_smooth;\n}\n\n// Filtre interne\n// [[Rcpp::export]]\nList internal_filter(const int N, arma::vec y, const int M, const int D, arma::mat Sigma, arma::mat x_prev, double sigma_y){\n  // Input //\n  // y : data\n  // M : number of particles\n  // D : dimension of data\n  // Sigma : Variance-covariance matrix\n  // x_prev : previous x\n  // sigma_y : variance of data\n  //set_seed(42);\n  \n  boost::mt19937 rng;\n  boost::normal_distribution<double> normdist(0., 1.);\n  \n  // Initialize particles and weights\n  arma::cube particles(M, D, N, arma::fill::zeros);\n  arma::cube weights(M, D, N, arma::fill::zeros);\n  arma::vec log_likelihood = arma::zeros(N);\n  \n  for(int n=0; n < N; n++){\n    for(int m=0; m < M; m++){\n      particles(m, 0, n) = 0.5 * x_prev(n, 0) + sqrt(Sigma(0, 0)) * normdist(rng);\n      weights(m, 0, n) = G(y(0), particles(m, 0, n), sqrt(sigma_y));\n    }\n    \n    log_likelihood[n] = log(mean(weights.slice(n).col(0)));\n    \n    // Normalization\n    double sum_weights = sum(weights.slice(n).col(0));\n    for(int m=0; m<M; m++){\n      weights(m, 0, n) = weights(m, 0 ,n)/sum_weights;\n    }\n    \n    for(int d=1; d<D; d++){\n      // Resampling\n      arma::vec resampling = Multinomial(M, weights.slice(n).col(d-1));\n      \n      // Standard deviation\n      double sd = Sigma(d, d) - pow(Sigma(d-1, d), 2)/Sigma(d-1, d-1);\n      \n      for(int m = 0; m < M; m++){\n        double mu = 0.5*x_prev(n, d) + Sigma(d-1, d)/Sigma(d-1, d-1)*(particles(resampling(m), d-1, n) - 0.5*x_prev(n, d-1));\n        particles(m, d, n) = sqrt(sd) * normdist(rng) + mu;\n        weights(m, d, n) = G(y(d), particles(m, d, n), sqrt(sigma_y));\n      }\n      \n      log_likelihood[n] += log(mean(weights.slice(n).col(d)));\n      \n      sum_weights = sum(weights.slice(n).col(d));\n      \n      for(int m = 0; m < M; m++){\n        weights(m, d, n) /= sum_weights;\n      }\n    }\n  }\n  return Rcpp::List::create(Rcpp::Named(\"Log_Likelihood\") = log_likelihood,\n                            Rcpp::Named(\"Particles\") = particles,\n                            Rcpp::Named(\"Weights\") = weights);\n}\n\n// [[Rcpp::export]]\narma::vec resampling_QMC(int n, arma::vec weights, arma::vec sobol){\n    \n    double sum_weights = weights(0);\n    int k = 0;\n    arma::vec sample = arma::zeros(n);\n    \n    for(int i=0; i < n;i++){\n        while (sobol(i) > sum_weights){\n            k++;\n            sum_weights += weights(k);\n        }\n        sample(i) = k;\n    }\n    return sample;\n}\n\n// Filtre interne (coordonnées) avec QMC\n// [[Rcpp::export]]\nList internal_filter_with_QMC(const int N, arma::vec y, const int M, const int D, arma::mat Sigma, arma::mat x_prev, double sigma_y){\n  // Input //\n  // y : data\n  // M : number of particles\n  // D : dimension of data\n  // Sigma : Variance-covariance matrix\n  // x_prev : previous x\n  // sigmay_y : variance of data\n  \n  //set_seed(42);\n  \n  // Initial particles\n  arma::cube particles(M, D, N, arma::fill::zeros);\n  arma::cube weights(M, D, N, arma::fill::zeros);\n  arma::cube particles_sorted(M, D, N, arma::fill::zeros);\n  arma::vec log_likelihood = arma::zeros(N);\n  \n  boost::math::normal dist(0.0, 1.0);\n  \n  Scrambled* a;\n  a = Scrambled_Create(1, 2, M);\n  \n  for(int n=0; n<N ; n++){\n    \n    arma::mat sobol_sequence = gen_sobol(2, M, a);\n    \n    for(int m=0; m < M; m++){\n      particles(m, 0, n) = 0.5*x_prev(n, 0) + sqrt(Sigma(0,0)) * quantile(dist, sobol_sequence(0, m));\n    }\n    \n    particles_sorted.slice(n).col(0) = sort(particles.slice(n).col(0));\n    \n    for(int m=0; m<M; m++){\n      weights(m, 0, n) = G(y(0), particles_sorted(m, 0, n), sqrt(sigma_y));\n    }\n    \n    log_likelihood[n] = log(mean(weights.slice(n).col(0)));\n    \n    // Normalization\n    double sum_weights = sum(weights.slice(n).col(0));\n    for(int m=0; m<M; m++){\n      weights(m, 0, n) /= sum_weights;\n    }\n    \n    for(int d=1; d < D; d++){\n      // Resampling\n      arma::mat sobol_sequence = gen_sobol(2, M, a);\n      arma::mat sobol_sequence_transpose = sobol_sequence.t();\n      \n      arma::vec resampling = resampling_QMC(M, weights.slice(n).col(d-1), sobol_sequence_transpose.col(0));\n      \n      // Standard deviation\n      double sd = Sigma(d, d) - pow(Sigma(d-1, d), 2)/Sigma(d-1, d-1);\n      \n      for(int m = 0; m < M; m++){\n        double mu = 0.5*x_prev(n, d) + Sigma(d-1,d)/Sigma(d-1,d-1)*(particles_sorted(resampling(m), d, n) - 0.5*x_prev(n, d-1));\n        particles(m, d, n) = sqrt(sd) * quantile(dist, sobol_sequence(1, m)) + mu;\n      }\n      \n      particles_sorted.slice(n).col(d) = sort(particles.slice(n).col(d));\n      \n      for(int m = 0; m < M; m++){\n        weights(m, d, n) = G(y(d), particles_sorted(m, d, n), sqrt(sigma_y));\n      }\n      \n      log_likelihood[n] += log(mean(weights.slice(n).col(d)));\n      \n      sum_weights = sum(weights.slice(n).col(d));\n      for(int m = 0; m < M; m++){\n        weights(m, d, n) = weights(m, d, n)/sum_weights;\n      }\n    }\n  }\n  return Rcpp::List::create(Rcpp::Named(\"Log_Likelihood\") = log_likelihood,\n                            Rcpp::Named(\"Particles\") = particles_sorted,\n                            Rcpp::Named(\"Weights\") = weights);\n}\n\ndouble g(const int &y, const double &x){\n  boost::math::poisson P(exp(x));\n  return pdf(P, y);\n}\n\n\nconst double log2pi = std::log(2.0 * M_PI);\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\ndouble dmvnrm_arma(arma::mat x,  \n                      arma::rowvec mean,  \n                      arma::mat sigma) { \n  \n  int xdim = x.n_rows;\n  double out;\n  arma::mat rooti = arma::trans(arma::inv(trimatu(arma::chol(sigma))));\n  double rootisum = arma::sum(log(rooti.diag()));\n  double constants = -(static_cast<double>(xdim)/2.0) * log2pi;\n  \n  arma::vec z = rooti * arma::trans( x.col(0) - mean) ;    \n  out = constants - 0.5 * arma::sum(z%z) + rootisum;     \n  return(exp(out));\n}\n\n\n// [[Rcpp::export]]\nint lattice_internal_filter(const int N, const int M, const int D, arma::mat prev_external_particles, arma::mat S, arma::vec y){\n  // prev_external_particles : N*(D**2) matrix\n  // y : vec of dim D**2\n  \n  boost::mt19937 rng;\n  boost::normal_distribution<double> normdist(0., 1.);\n  \n  arma::cube internal_particles(M, D*D, N, arma::fill::zeros);\n  arma::mat weights(M, D*D, arma::fill::zeros);\n  \n  int steps = log(D*D)/log(2);\n  \n  // for each external particle\n  for(int n=0; n<N; n++){\n    \n    arma::mat particles = internal_particles.slice(n);\n    \n    for(int k=0; k<= steps; k++){\n      int d = 0 ;// component index\n      while(d < D*D){\n        \n        // Step 0\n        if(k==0){ \n          for(int m=0; m<M; m++){\n            particles(m, d) = prev_external_particles(n,d) + sqrt(S(d,d))*normdist(rng);\n            weights(m, d) = g(y[d], particles(m, d));\n          }\n        }\n        \n        // Step 1\n        if(k==1){ \n          arma::mat v(M,M, arma::fill::zeros);\n          \n          for(int m=0;m<M; m++){\n            for(int p=0; p<M; p++){\n              // il faut trouver la bonne structure pour les indices !\n              arma::vec x = {particles(p,d), particles(m, d+1)};;\n              // mat rowvec mat\n              dmvnrm_arma(x, prev_external_particles.submat(n, d, n, d+1), S.submat(arma::span(d, d+1), arma::span(d, d+1)));\n              v(m,p) = weights(m, d)*weights(p, d+1);\n            }\n          }\n          \n        }\n      }\n    }\n  }\n  return 0;\n}\n\n\n\n/*\n      if(k==1){ # Etape 1 : on regroupe par couple (x_k, x_{k+1})\n# on regarde toutes les combinaisons possibles de particules et on cacule les poids associés\n        v <- array(1, dim=c(M, M))\n        for(n in 1:M){\n          for(m in 1:M){\n            v[n, m] <- ((weights[n, d]*weights[m, d+1])*  \n              dmvnorm(c(internal_particles[p, n, d], internal_particles[p, m, d+1]), x_prev[d:(d+1)], S[d:(d+1), d:(d+1)]) *\n              dnorm(internal_particles[p, n, d], x_prev[d], S[d, d])*dnorm(internal_particles[p, m, d+1], x_prev[d+1], S[d+1, d+1])\n            )\n          }\n        }\n        Z[p] = Z[p] * mean(v)\n          \n# On sample des couples selon ces poids\n          V <- c(t(v)) # matrice aplatie en vecteur en concaténant les lignes\n            sample_indexes <- sample(x=M**2, size = M, replace = T, prob = V)\n            \n# %/% (division entière) ; %% (modulo)\n# 12 <-> (2,2) and 20 <-> (2, 10)\n            for(i in 1:length(sample_indexes)){\n              if(sample_indexes[i]%%M == 0){\n                n <- sample_indexes[i]/M\n                m <- M\n              } else {\n                n <- sample_indexes[i]%/%M + 1\n                m <- sample_indexes[i]%%M\n              }\n              updated_internal_particles[p, i, d:(d+1)] <- c(internal_particles[p, n, d], internal_particles[p, m, d+1])\n            }\n      }\n      \n    \n      if(k > 1){ # Etape k > 1 : on regroupe par tuple\n        internal_particles <- updated_internal_particles\n        \n# on regarde toutes les combinaisons possibles de particules et on cacule les poids associés\n        v <- array(1, dim=c(M, M))\n          deb <- d # debut\n          mil <- d+2**(k-1) # milieu\n          fin <- d+2**(k)-1 # fin\n          for(n in 1:M){\n            for(m in 1:M){\n              v[n, m] <-  (dmvnorm(c(internal_particles[p, n, deb:(mil-1)], internal_particles[p, m, mil:fin]), x_prev[deb:fin], S[deb:fin, deb:fin]) *\n                dmvnorm(internal_particles[p, n, deb:(mil-1)], x_prev[deb:(mil-1)], S[deb:(mil-1), deb:(mil-1)]) * \n                dmvnorm(internal_particles[p, m, mil:fin], x_prev[mil:fin], S[mil:fin, mil:fin]))\n            }\n          }\n          \n          Z[p] = Z[p] * mean(v)\n# On sample des couples selon ces poids\n            V <- c(t(v)) # matrice en vecteur en concaténant les lignes\n            sample_indexes <- sample(x=M**2, size = M, replace = T, prob = V)\n            \n# To get couple : index%/%N (division entière) index%%N (modulo)\n            \n            for(i in 1:length(sample_indexes)){\n              if(sample_indexes[i]%%M == 0){\n                n <- sample_indexes[i]/M\n                m <- M\n              }else{\n                n <- sample_indexes[i]%/%M + 1\n                m <- sample_indexes[i]%%M\n              }\n              updated_internal_particles[p, i, deb:fin] <- c(internal_particles[p, n, deb:(mil-1)], internal_particles[p, m, mil:fin])\n            }\n      }\n# Next block\n      d <- d+2**k\n    }\n  }\n}\n*/",
    "created" : 1501749142972.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1087289201",
    "id" : "56B205AB",
    "lastKnownWriteTime" : 1502094949,
    "path" : "~/Google Drive/ENSAE/2A/Stage2A/bRistol/RSQMC/src/SQMC.cpp",
    "project_path" : "RSQMC/src/SQMC.cpp",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "cpp"
}
{
    "contents" : "library(mvtnorm)\nlibrary(RSQMC)\nsource(\"/Users/Schreuder/Google Drive/ENSAE/2A/Stage2A/bRistol/Example1Functions.R\") \n\nlattice_internal_filter(N, M, D, particles[, , 1] , S, y)\n\n# SMC parameters\nD <- 4 # dimension -> DxD square\nN <- 40 # number of external particles\nM <- 10 # number of internal particles\nT_ = 15 # time\nsigma_y = 0.25**2\n\nmu = 1\nrho = 0.9\n\n# Multivariate density of independant Poisson variables\ng <- function(y, x){\n  prod <- 1\n  for(i in 1:length(y)){\n    prod <- prod * dpois(y[i], exp(x[i]))\n    #prod <- prod * dnorm(y[i], x[i], sigma_y)\n  }\n  return(prod)\n}\n\n\n# Covariance matrix construction\nS_inv <- matrix(0, D**2, D**2)\ntau = 1.\nlambda = 1.\n\nfor(n in 1:D){\n  for(k in 1:D){\n    nb_neighbours = 0\n    # (n,k) gives n*D + k position in vector\n    vector_index <- (n-1)*D + k\n    if (n > 1){ # upper neighbour\n      S_inv[vector_index, vector_index - D] <- -lambda\n      nb_neighbours = nb_neighbours + 1\n    }\n    if (n < D){ # lower neighbour\n      S_inv[vector_index, vector_index + D] <- -lambda\n      nb_neighbours = nb_neighbours + 1\n    }\n    if(k > 1){ # left neighbour\n      S_inv[vector_index, vector_index - 1 ] <- -lambda \n      nb_neighbours = nb_neighbours + 1\n    }\n    if (k < D){ # right neighbour\n      S_inv[vector_index, vector_index + 1] <- -lambda\n      nb_neighbours = nb_neighbours + 1\n    }\n    S_inv[vector_index, vector_index] = tau + 2*nb_neighbours*lambda\n  }\n}\n\nS <- solve(S_inv) # covariance matrix\n\nS <- 4*S\n\n# Trajectory simulation\nx <- matrix(0, D**2, T_)\ny <- matrix(0, D**2, T_)\n\nx[, 1] <- mvrnorm(n = 1, matrix(mu, D**2), S)\nfor(d in 1:(D**2)){\n  y[d, 1] <- rpois(1, exp(x[d, 1]))\n  #y[d, 1] <- rnorm(1, x[d, 1], sigma_y)\n}\n\nfor(t in 2:T_){\n  x[, t] <- mu + rho*(x[, t-1]-mu) + mvrnorm(n = 1, matrix(0, D**2), S)\n  for(d in 1:(D**2)){\n    y[d, t] <- rpois(1, exp(x[d, t]))\n    #y[d, t] <- rnorm(1, x[d, t], sigma_y)\n  }\n}\n\n# 2^{nb_etapes} = D^2 =>\nnb_etapes <- log(D**2)/log(2)\n\nparticles <- array(0, dim=c(N, D**2, T_))\nresampling_weights <- array(0, N)\n\n# Peut etre qu'il faut lancer un filtre interne pour l'initialisation ?\nfor(p in 1:N){\n  particles[p, , 1] <- mvrnorm(n = 1, matrix(mu, D**2), S)\n  resampling_weights[p] <- g(y[, 1], particles[p, , 1])\n}\n\nresampling_weights = resampling_weights/sum(resampling_weights)\n\nresampling = sample(N, N, replace=T, resampling_weights)\n\na <- particles[, , 1]\nparticles[, , 1] <- a[resampling, ]\n\nfor(t in 2:T_){\n  print(t)\n  # Filtre interne lancé pour chaque particule externe\n  internal_particles <- array(0, dim=c(N, M, D**2))\n  updated_internal_particles <- array(0, dim=c(N, M, D**2))\n  weights <- array(0, dim=c(M, D**2))\n  \n  # Likelihood estimate\n  Z = matrix(1, N)\n  \n  for(p in 1:N){\n    x_prev <- mu + rho*(particles[p, , t-1] - mu)\n    \n    for(k in 0:nb_etapes){\n      d = 1 # indice de composante\n      while(d <= D**2){\n\n        if(k==0){ # Etape 0 : initalisation\n          for(m in 1:M){\n            # On initialise chaque particule en simulant selon la loi marginale\n            internal_particles[p, m, d] <- x_prev[d] + rnorm(1, 0, S[d, d])\n            weights[m, d] <- g(y[d, t], internal_particles[p, m, d])\n          }\n        }\n        \n        if(k==1){ # Etape 1 : on regroupe par couple (x_k, x_{k+1})\n          # on regarde toutes les combinaisons possibles de particules et on cacule les poids associés\n          v <- array(1, dim=c(M, M))\n          for(n in 1:M){\n            for(m in 1:M){\n              v[n, m] <- ((weights[n, d]*weights[m, d+1])*  \n                dmvnorm(c(internal_particles[p, n, d], internal_particles[p, m, d+1]), x_prev[d:(d+1)], S[d:(d+1), d:(d+1)]) *\n                dnorm(internal_particles[p, n, d], x_prev[d], S[d, d])*dnorm(internal_particles[p, m, d+1], x_prev[d+1], S[d+1, d+1])\n                )\n            }\n          }\n          Z[p] = Z[p] * mean(v)\n          \n          # On sample des couples selon ces poids\n          V <- c(t(v)) # matrice aplatie en vecteur en concaténant les lignes\n          sample_indexes <- sample(x=M**2, size = M, replace = T, prob = V)\n          \n          # %/% (division entière) ; %% (modulo)\n          # 12 <-> (2,2) and 20 <-> (2, 10)\n          for(i in 1:length(sample_indexes)){\n            if(sample_indexes[i]%%M == 0){\n              n <- sample_indexes[i]/M\n              m <- M\n            } else {\n              n <- sample_indexes[i]%/%M + 1\n              m <- sample_indexes[i]%%M\n            }\n            updated_internal_particles[p, i, d:(d+1)] <- c(internal_particles[p, n, d], internal_particles[p, m, d+1])\n          }\n        }\n        \n        if(k > 1){ # Etape k > 1 : on regroupe par tuple\n          internal_particles <- updated_internal_particles\n          \n          # on regarde toutes les combinaisons possibles de particules et on cacule les poids associés\n          v <- array(1, dim=c(M, M))\n          deb <- d # debut\n          mil <- d+2**(k-1) # milieu\n          fin <- d+2**(k)-1 # fin\n          for(n in 1:M){\n            for(m in 1:M){\n              v[n, m] <-  (dmvnorm(c(internal_particles[p, n, deb:(mil-1)], internal_particles[p, m, mil:fin]), x_prev[deb:fin], S[deb:fin, deb:fin]) *\n                             dmvnorm(internal_particles[p, n, deb:(mil-1)], x_prev[deb:(mil-1)], S[deb:(mil-1), deb:(mil-1)]) * \n                             dmvnorm(internal_particles[p, m, mil:fin], x_prev[mil:fin], S[mil:fin, mil:fin]))\n            }\n          }\n          \n          Z[p] = Z[p] * mean(v)\n          # On sample des couples selon ces poids\n          V <- c(t(v)) # matrice en vecteur en concaténant les lignes\n          sample_indexes <- sample(x=M**2, size = M, replace = T, prob = V)\n          \n          # To get couple : index%/%N (division entière) index%%N (modulo)\n          \n          for(i in 1:length(sample_indexes)){\n            if(sample_indexes[i]%%M == 0){\n              n <- sample_indexes[i]/M\n              m <- M\n            }else{\n              n <- sample_indexes[i]%/%M + 1\n              m <- sample_indexes[i]%%M\n            }\n            updated_internal_particles[p, i, deb:fin] <- c(internal_particles[p, n, deb:(mil-1)], internal_particles[p, m, mil:fin])\n          }\n        }\n        # Next block\n        d <- d+2**k\n      }\n    }\n  }\n  \n  Z = Z/sum(Z)\n  \n  resampling_ancestor = sample(N, N, replace=T, Z)\n  sampling = sample(M, N, replace=T, matrix(1/M, M))\n  for(p in 1:N){\n    particles[p, , t] <- updated_internal_particles[resampling_ancestor[p], sampling[p], ]\n  }\n}\n\nfor(d in 1:D**2){\n  plot(x[d, ])\n  lines(x[d, ])\n  lines(apply(particles[, d, ], 2, mean), col='red')\n}",
    "created" : 1501504204342.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4181284991",
    "id" : "489F372E",
    "lastKnownWriteTime" : 1502095036,
    "path" : "~/Google Drive/ENSAE/2A/Stage2A/bRistol/Lattice.R",
    "project_path" : "Lattice.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}